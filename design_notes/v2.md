# VirtualiZarr V2 architecture discussion

## Goals

- Extensible and easily understandable entry-point system for new backends
- Modular code base that uses Obspec for the object storage interface abstraction, Zarr as the core data model, and Xarray for the concatenation and merging of Zarr stores

## Related issues

- [Fragility of url auto-parsing logic](https://github.com/zarr-developers/VirtualiZarr/issues/561)
- [Use obstore / obspec for globbing in `open_virtual_mfdataset`](https://github.com/zarr-developers/VirtualiZarr/issues/569)
- [Function definition for open_virtual_dataset in next major release](https://github.com/zarr-developers/VirtualiZarr/issues/553)
- [Support passing configuration options to default_object_store](https://github.com/zarr-developers/VirtualiZarr/issues/559)
- [Redefine Virtual Readers as func(filepath) -> ManifestStore](https://github.com/zarr-developers/VirtualiZarr/issues/498)
- [Make xarray an optional dependency?](https://github.com/zarr-developers/VirtualiZarr/issues/521)
- [Re-implement loadable_variables using ManifestStore ](https://github.com/zarr-developers/VirtualiZarr/issues/473)
- [Should we try to use Obstore for reading files?](https://github.com/zarr-developers/VirtualiZarr/issues/476)
- [Challenges with earthaccess.open_virtual_mfdataset for grouped netCDFs with nested structure](https://github.com/zarr-developers/VirtualiZarr/issues/487)
- [Docs on how to write a custom reader](https://github.com/zarr-developers/VirtualiZarr/issues/452)
- [Make readers pluggable via entrypoint system](https://github.com/zarr-developers/VirtualiZarr/issues/245)
- [Architecture diagram](https://github.com/zarr-developers/VirtualiZarr/issues/225)

## Data structures

- `ChunkManifest`: An object defining the paths, chunk byte offsets, lengths of one virtual array.
- `ManifestArray`: A chunk manifest and its associated Zarr V3 ArrayMetadata
- `ManifestGroup`: ManifestGroups are a way to organizing child groups and arrays into a data hierarchy. Contains Zarr `GroupMetadata` and one or more ManifestGroups and/or ManifestArrays.
- `ManifestStore`: A ManifestGroup and its associated ObjectReader (see protocol below).
- `xarray.Dataset`: Contains ManifestArray-backed variables and (optionally) in-memory NumPy-backed variables.

## Protocols

- `ObjectReader`: get bytes from files on object storage or disk
- `VirtualZarrBackend`: construct a ManifestStore from a file

```python
class ObjectReader(Protocol):
    """
    Protocol for file operations for downstream libraries
    """

    async get_range_async(
        self,
        path: str,
        *,
        start: int,
        end: int | None = None,
        length: int | None = None
    ) -> Bytes :
        ...

```


```python
class VirtualZarrBackend(protocol):
    """
    Protocol for creating a virtual zarr dataset from a file
    """

    @staticmethod
    def open_virtual_store(
        url_string: str,
        object_reader: ObjectReader,
        *,
        virtual_backend_kwargs: dict | None = None,
    ) → VirtualStore:
        ...
```

## Top-level API functions

- `open_virtual_dataset` - construct a Xarray Dataset with NumPy and/or ManifestArray-backed variables from a file
- `open_virtual_mfdataset` - construct a Xarray Dataset with NumPy and/or ManifestArray-backed variables from many files

> **NOTE**: Here the construction of a virtual dataset from a manifest store would happen in the top-level function rather than the backends, which would need to implement `open_virtual_store` rather than `open_virtual_dataset`

```python
 def open_virtual_dataset(
    url_string: str,
    object_reader: ObjectReader,
    backend: VirtualBackend,
    *,
    drop_variables: Iterable[str] | None = None,
    loadable_variables: Iterable[str] | None = None,
    decode_times: bool | None = None,
    cftime_variables: Iterable[str] | None = None,
    indexes: Mapping[str, Index] | None = None,
    virtual_backend_kwargs: dict | None = None,
) → Dataset
    """
    Method for creating virtual Xarray dataset, only implemented in top level API
    """
    backend.open_virtual_store(
        filepath,
        virtual_backend_kwargs = virtual_backend_kwargs,
        store=store
    )
    ds = manifest_store.to_virtual_dataset(
        loadable_variables=loadable_variables,
        decode_times=decode_times,
        indexes=indexes,
    )
    return ds
```
