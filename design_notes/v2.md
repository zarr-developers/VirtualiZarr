# VirtualiZarr V2 architecture discussion

## Goals

- Extensible and easily understandable entry-point system for new backends
- Modular code base that uses Obspec for the object storage interface abstraction, Zarr as the core data model, and Xarray for the concatenation and merging of Zarr stores

## Related issues

- [Fragility of url auto-parsing logic](https://github.com/zarr-developers/VirtualiZarr/issues/561)
- [Use obstore / obspec for globbing in `open_virtual_mfdataset`](https://github.com/zarr-developers/VirtualiZarr/issues/569)
- [Function definition for open_virtual_dataset in next major release](https://github.com/zarr-developers/VirtualiZarr/issues/553)
- [Support passing configuration options to default_object_store](https://github.com/zarr-developers/VirtualiZarr/issues/559)
- [Redefine Virtual Readers as func(filepath) -> ManifestStore](https://github.com/zarr-developers/VirtualiZarr/issues/498)
- [Make xarray an optional dependency?](https://github.com/zarr-developers/VirtualiZarr/issues/521)
- [Re-implement loadable_variables using ManifestStore ](https://github.com/zarr-developers/VirtualiZarr/issues/473)
- [Should we try to use Obstore for reading files?](https://github.com/zarr-developers/VirtualiZarr/issues/476)
- [Challenges with earthaccess.open_virtual_mfdataset for grouped netCDFs with nested structure](https://github.com/zarr-developers/VirtualiZarr/issues/487)
- [Docs on how to write a custom reader](https://github.com/zarr-developers/VirtualiZarr/issues/452)
- [Make readers pluggable via entrypoint system](https://github.com/zarr-developers/VirtualiZarr/issues/245)
- [Architecture diagram](https://github.com/zarr-developers/VirtualiZarr/issues/225)

## Data structures

- `Manifest`: An object defining the paths, chunk byte offsets, lengths of one virtual array.
- `ManifestArray`: `ManifestArrays` contain a single chunk manifest and its associated Zarr V3 `ArrayMetadata` and provide a way to concatenate and stack multiple arrays.
- `ManifestGroup`: `ManifestGroup`s are a way to organize child groups and arrays into a data hierarchy. Contains Zarr V3 `GroupMetadata` and one or more `ManifestGroup`s and/or `ManifestArray`s.
- `ManifestStore`: An implementation of Zarr's store API that contains a `ManifestGroup` and an `AsyncObjectReader` (see protocol below). The `ManifestStore` redirects incoming `get` requests to the byte ranges contained within the `ChunkManifest`.
- `xarray.Dataset`: Contains `ManifestArray`-backed variables and (optionally) in-memory NumPy-backed variables.

## Definitions

- `Parser` - A parser is a function that constructs a `ManifestStore` from an `AsyncObjectReader` and a `file_url`.

## Protocols

**Note**: We anticipate using [obspec](https://developmentseed.org/obspec/latest/) with the following typing in the future, but currently use only `ObjectStore` rather than the general interface definition.

```python
from obspec import GetAsync, GetRangeAsync, List

class AsyncObjectReader(GetAsync, GetRangeAsync, List):
    ...

```

```python
class Parser(protocol):
    """
    Callback protocol for creating a virtual zarr store from a file
    """
    def __call__(
        self,
        file_url: str,
        object_store: ObjectStore,
        *,
    ) → ManifestStore:
        ...
```

## Top-level API functions

- `open_virtual_dataset` - construct a Xarray Dataset with NumPy and/or ManifestArray-backed variables from a file
- `open_virtual_mfdataset` - construct a Xarray Dataset with NumPy and/or ManifestArray-backed variables from many files

> **NOTE**: Here the construction of a virtual dataset from a manifest store would happen in the top-level function rather than the backends.

```python
 def open_virtual_dataset(
    file_url: str,
    object_store: ObjectStore,
    parser: Parser,
    *,
    drop_variables: Iterable[str] | None = None,
    loadable_variables: Iterable[str] | None = None,
    decode_times: bool | None = None,
    cftime_variables: Iterable[str] | None = None,
    indexes: Mapping[str, Index] | None = None,
) → Dataset
    """
    Method for creating virtual Xarray dataset, only implemented in top level API
    """
    manifest_store = parser(
        file_url = file_url,
        object_store = object_store,
    )
    vds = manifest_store.to_virtual_dataset(
        loadable_variables=loadable_variables,
        decode_times=decode_times,
        indexes=indexes,
        drop_variables=drop_variables
    )
    return vds
```

> **NOTE**: Here the construction of a virtual dataset from a manifest store would happen in the top-level function rather than the backends.

```python
 def open_virtual_mfdataset(
    paths: str | os.PathLike | Sequence[str | os.PathLike] | "NestedSequence[str | os.PathLike]",
    object_store: ObjectStore,
    parser: Parser,
    *,
    concat_dim: (
        str
        | DataArray
        | Index
        | Sequence[str]
        | Sequence[DataArray]
        | Sequence[Index]
        | None
    ) = None,
    compat: "CompatOptions" = "no_conflicts",
    preprocess: Callable[[Dataset], Dataset] | None = None,
    data_vars: Literal["all", "minimal", "different"] | list[str] = "all",
    coords="different",
    combine: Literal["by_coords", "nested"] = "by_coords",
    parallel: Literal["dask", "lithops", False] | Executor = False,
    join: "JoinOptions" = "outer",
    attrs_file: str | os.PathLike | None = None,
    combine_attrs: "CombineAttrsOptions" = "override",
    **kwargs,
) → Dataset
    """
    Open multiple files as a single virtual dataset, only implemented in top level API.
    """
    ...
```
