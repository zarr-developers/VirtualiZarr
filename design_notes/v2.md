# VirtualiZarr V2 architecture discussion

## Goals

- Extensible and easily understandable entry-point system for new backends
- Modular code base that uses Obspec for the object storage interface abstraction, Zarr as the core data model, and Xarray for the concatenation and merging of Zarr stores

## Related issues

- [Fragility of url auto-parsing logic](https://github.com/zarr-developers/VirtualiZarr/issues/561)
- [Use obstore / obspec for globbing in `open_virtual_mfdataset`](https://github.com/zarr-developers/VirtualiZarr/issues/569)
- [Function definition for open_virtual_dataset in next major release](https://github.com/zarr-developers/VirtualiZarr/issues/553)
- [Support passing configuration options to default_object_store](https://github.com/zarr-developers/VirtualiZarr/issues/559)
- [Redefine Virtual Readers as func(filepath) -> ManifestStore](https://github.com/zarr-developers/VirtualiZarr/issues/498)
- [Make xarray an optional dependency?](https://github.com/zarr-developers/VirtualiZarr/issues/521)
- [Re-implement loadable_variables using ManifestStore ](https://github.com/zarr-developers/VirtualiZarr/issues/473)
- [Should we try to use Obstore for reading files?](https://github.com/zarr-developers/VirtualiZarr/issues/476)
- [Challenges with earthaccess.open_virtual_mfdataset for grouped netCDFs with nested structure](https://github.com/zarr-developers/VirtualiZarr/issues/487)
- [Docs on how to write a custom reader](https://github.com/zarr-developers/VirtualiZarr/issues/452)
- [Make readers pluggable via entrypoint system](https://github.com/zarr-developers/VirtualiZarr/issues/245)
- [Make Manifests' in-memory reference structure pluggable](https://github.com/zarr-developers/VirtualiZarr/issues/246)
- [Architecture diagram](https://github.com/zarr-developers/VirtualiZarr/issues/225)

## Data structures

- `ChunkManifest`: An object defining the paths, chunk byte offsets, lengths of one virtual array.
- `ManifestArray`: Contains one ChunkManifest and Zarr V3 ArrayMetadata
- `ManifestGroup`: ManifestGroups are a way to organizing child groups and arrays into a data hierarchy. Contains Zarr `GroupMetadata` and one or more ManifestGroups and/or ManifestArrays.
- `ManifestStore`: A ManifestGroup and its associated FileReader (see protocols below).
- `xarray.Dataset`: Contains ManifestArray-backed variables

## Protocols

> **Note:** Protocols over ABCs would allow third party backends to be less tightly coupled to VirtualiZarr
>
> **Question:** How do we simplify these protocol definitions using obspec?

- `FileReader`: read bytes from files on object storage or disk
- `VirtualZarrBackend`: construct a ManifestStore from a file

```python
class FileReader(Protocol):
    """
    Protocol for file operations for downstream libraries
    """

    def read(self, size: int, /) -> bytes:
        ...

    def seek(self, offset: int, whence: int = 0, /):
        ...

    def tell(self) -> int:
        ...

    async get_range_async(
        self,
        path: str,
        *,
        start: int,
        end: int | None = None,
        length: int | None = None
    ) -> Bytes :
        ...

    async get_async(
        self,
        path: str,
        *,
        options: int | None = None,
        length: int | None = None
    ) -> GetResult :
        ...

```


```python
class VirtualZarrBackend(protocol):
    """
    Protocol for creating a virtual zarr dataset from a file
    """

    @staticmethod
    def open_virtual_store(
        filepath: str,
        *,
        virtual_backend_kwargs: dict | None = None,
        reader_options: ObspecReaderOptions | dict | None = None,
    ) → VirtualStore:
        ...
```

> **Question:** How do we define this protocol to allow for strict typing for some readers (e.g., obstore-backed) and not others (e.g., fsspec-backed)?

> **Note:** Could ObspectReaderOptions be typed as follows?

```python
ObspecReaderOptions(TypedDict):
    s3_config: S3Config | None = None
    azure_config: AzureConfig | None = None
    gcs_config: GCSConfig | None = None
    client_options: NotRequired[ClientConfig]
    retry_config: NotRequired[RetryConfig]
    credential_provider: NotRequired[Callable]
```
## Top-level API functions

- `open_virtual_dataset` - construct a Xarray Dataset with NumPy and/or ManifestArray-backed variables from a file
- `open_virtual_mfdataset` - construct a Xarray Dataset with NumPy and/or ManifestArray-backed variables from many files

> **NOTE**: Here the construction of a virtual dataset from a manifest store would happen in the top-level function rather than the backends, which would need to implement `open_virtual_store` rather than `open_virtual_dataset`

```python
 def open_virtual_dataset(
    filepath: str,
    *,
    cache: bool = False,
    drop_variables: Iterable[str] | None = None,
    loadable_variables: Iterable[str] | None = None,
    decode_times: bool | None = None,
    cftime_variables: Iterable[str] | None = None,
    indexes: Mapping[str, Index] | None = None,
    virtual_backend_kwargs: dict | None = None,
    reader_options: ObspecReaderOptions | dict | None = None,
    backend: type[VirtualBackend] | None = None
) → Dataset
    """
    Method for creating virtual Xarray dataset, only implemented in top level API
    """
    # Guess backend if not provided based on filepath or magic bytes
    if cache:
        orig_fp = filepath
        filepath = cache_file(orig_fp, reader_options)
    if not backend:
        backend = guess_backend(filepath, reader_options)
    backend.open_virtual_store(
        filepath,
        virtual_backend_kwargs = virtual_backend_kwargs,
        reader_options=reader_options
    )
    ds = manifest_store.to_virtual_dataset(
        loadable_variables=loadable_variables,
        decode_times=decode_times,
        indexes=indexes,
    )
    if cache:
        ds = ds.virtualize.rename_paths(orig_fp)
    return ds
```

## Backends

> **Question**: Is there a reason to have a backend per kerchunk reader rather than a single backend that could be used for all of them?

```Python
class KerchunkVirtualBackend():
    """
    Backend for using any Kerchunk readers in VirtualiZarr
    """

    @staticmethod
    def open_virtual_store(
        filepath: str,
        *,
        virtual_backend_kwargs: dict | None = None,
        reader_options: ObspecReaderOptions | dict | None = None,
    ) → VirtualStore:
        kerchunk_backend = virtual_backend_kwargs.get("kerchunk_backend")
        kerchunk_options = virtual_backend_kwargs.get("kerchunk_options")
        refs = kerchunk_backend(filepath, inline_threshold=0, **kerchunk_options).translate()
        return manifeststore_from_kerchunk_refs(
            refs,
            group=group,
            fs_root=Path.cwd().as_uri(),
        )
```
