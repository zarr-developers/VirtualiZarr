# VirtualiZarr V2 architecture discussion

## Goals

- Extensible and easily understandable entry-point system for new backends
- Modular code base that uses Obspec for the object storage interface abstraction, Zarr as the core data model, and Xarray for the concatenation and merging of Zarr stores

## Related issues

- [Fragility of url auto-parsing logic](https://github.com/zarr-developers/VirtualiZarr/issues/561)
- [Use obstore / obspec for globbing in `open_virtual_mfdataset`](https://github.com/zarr-developers/VirtualiZarr/issues/569)
- [Function definition for open_virtual_dataset in next major release](https://github.com/zarr-developers/VirtualiZarr/issues/553)
- [Support passing configuration options to default_object_store](https://github.com/zarr-developers/VirtualiZarr/issues/559)
- [Redefine Virtual Readers as func(filepath) -> ManifestStore](https://github.com/zarr-developers/VirtualiZarr/issues/498)
- [Make xarray an optional dependency?](https://github.com/zarr-developers/VirtualiZarr/issues/521)
- [Re-implement loadable_variables using ManifestStore ](https://github.com/zarr-developers/VirtualiZarr/issues/473)
- [Should we try to use Obstore for reading files?](https://github.com/zarr-developers/VirtualiZarr/issues/476)
- [Challenges with earthaccess.open_virtual_mfdataset for grouped netCDFs with nested structure](https://github.com/zarr-developers/VirtualiZarr/issues/487)
- [Docs on how to write a custom reader](https://github.com/zarr-developers/VirtualiZarr/issues/452)
- [Make readers pluggable via entrypoint system](https://github.com/zarr-developers/VirtualiZarr/issues/245)
- [Architecture diagram](https://github.com/zarr-developers/VirtualiZarr/issues/225)

## Data structures

- `ChunkManifest`: An object defining the paths, chunk byte offsets, lengths of one virtual array.
- `ManifestArray`: A chunk manifest and its associated Zarr V3 ArrayMetadata
- `ManifestGroup`: ManifestGroups are a way to organize child groups and arrays into a data hierarchy. Contains Zarr `GroupMetadata` and one or more ManifestGroups and/or ManifestArrays.
- `ManifestStore`: An implementation of Zarr's store API that contains a ManifestGroup and an AsyncObjectReader (see protocol below).
- `xarray.Dataset`: Contains ManifestArray-backed variables and (optionally) in-memory NumPy-backed variables.

## Definitions

- `AsyncObjectReader` - An implementation of the `GetAsync` and `GetRangeAsync` protocols defined in `obspec`. `AsyncObjectReader`s are used to load arrays in a `ManifestStore`. `AsyncObjectReader`s may be used by a `Backend` to construct a `ManifestStore`.
- `ReadableFile` - A reader that implements the `Read`, `Seek`, and `Tell` methods using a similar interface as a [Python BufferedReader](https://docs.python.org/3/library/io.html#io.BufferedReader). `ReadableFile`s may be used by a `Backend` to construct a `ManifestStore`. If required, the `Backend` should construct the `ReadableFile` from the `AsyncObjectReader` and file URL.
- `Backend` - A backend is a function that constructs a `ManifestStore` from an `AsyncObjectReader` and optionally `kwargs` specified using `virtual_backend_kwargs`. If necessary, a `Backend` may chose to construct a `ReadableFile` from an `AsyncObjectReader`.

## Protocols

```python
from obspec import GetAsync, GetRangeAsync, Read, Seek, Tell

class AsyncObjectReader(GetAsync, GetRangeAsync):
    ...

class ReadableFile(Read, Seek, Tell):
    ...
```

```python
class Backend(protocol):
    """
    Callback protocol for creating a virtual zarr store from a file
    """
    def __call__(
        file: ReadableFile,
        object_reader: ObjectReader,
        *,
        virtual_backend_kwargs: dict | None = None,
    ) → ManifestStore:
        ...
```

## Top-level API functions

- `open_virtual_dataset` - construct a Xarray Dataset with NumPy and/or ManifestArray-backed variables from a file
- `open_virtual_mfdataset` - construct a Xarray Dataset with NumPy and/or ManifestArray-backed variables from many files

> **NOTE**: Here the construction of a virtual dataset from a manifest store would happen in the top-level function rather than the backends.

```python
 def open_virtual_dataset(
    readable_file: ReadableFile,
    object_reader: AsyncObjectReader,
    backend: Backend,
    *,
    drop_variables: Iterable[str] | None = None,
    loadable_variables: Iterable[str] | None = None,
    decode_times: bool | None = None,
    cftime_variables: Iterable[str] | None = None,
    indexes: Mapping[str, Index] | None = None,
    virtual_backend_kwargs: dict | None = None,
) → Dataset
    """
    Method for creating virtual Xarray dataset, only implemented in top level API
    """
    manifest_store = backend(
        file = readable_file,
        object_reader = object_reader,
        virtual_backend_kwargs = virtual_backend_kwargs,
    )
    ds = manifest_store.to_virtual_dataset(
        loadable_variables=loadable_variables,
        decode_times=decode_times,
        indexes=indexes,
    )
    return ds
```
